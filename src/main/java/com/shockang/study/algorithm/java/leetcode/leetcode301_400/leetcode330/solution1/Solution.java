package com.shockang.study.algorithm.java.leetcode.leetcode301_400.leetcode330.solution1;

/**
 * 如果我有砝码0，能称的重量为0
 * 再加一个砝码1，能称的重量不到2    1
 * 再加一个砝码2，能称的重量不到4    1    1+2
 * 再加一个砝码4，能称的重量不到8    1    2    1+2    4  1+4    1+2+4
 * 再加一个砝码8，能称的重量不到16（16以内的全都能称出来）
 * 因为我每次前一步已经完全覆盖[0，n),再加一个n kg的不就能覆盖[0，2n)了吗。
 * 同时为了加的次数最少我们才这样加，不需要1，2，3，4，5.....每种砝码都有。
 * 只有这样先做到局部加砝码最少，才能保证到后边n很大时加的砝码最少。
 *
 * @author Shockang
 */
public class Solution {
	public int minPatches(int[] nums, int n) {
		int res = 0;
		long x = 1;
		int len = nums.length, i = 0;
		// 能连续覆盖的重量还没到n，有两种情况：断码(缺砝码)，或者还有砝码没加
		while (x <= n) {
			if (i < len && nums[i] <= x) {
				x += nums[i];
				i++;
				//上面判断语句可能不好理解，若现有砝码1, 4, 6, n为10，当一次循环后砝码1已计入x,x=2，但是nums[1]=4>2;
				//这说明断码了，我们需要的是重量为x=2的砝码，所以加一个，现在能称的重量就能覆盖到原来的2倍=4了（不到4）
				//然后nums[1]=4就等于4，4的砝码我们刚好有，加进来，现在能称的重量就能覆盖到原来的2倍=8了（不到8）
				//然后nums[2]=6<8，这个不是必需的砝码，加进来，现在能称的重量就能覆盖到8+6=14了（不到14）
			} else {
				//加一个现在刚好覆盖不到的重量的砝码，覆盖范围翻倍
				x *= 2;
				//计数+1
				res++;
			}
		}
		return res;
	}
}